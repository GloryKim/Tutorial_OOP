//
//  Prg2-7.cpp
//  Glory_C++
//
//  Created by Glory on 2020/09/29.
//

/*
변수를 초기화할 떄 Literal을 사용하는 프로그램
*/

#include <iostream>
using namespace std;

int main()
{
  // 변수 선언과 초기화
  int x = -1111;
  unsigned int y = 1234;
  unsigned int z = -2345;
  unsigned int t = 124.56;
  // 초기화된 값 출력
  cout << x << endl;
  cout << y << endl;
  cout << z << endl;
  cout << t;
  return 0;
}

/*
 <리터럴과 상수 세부 설명 내용>
 
 상수(Constant)란?
 먼저 상수와 리터럴 둘 다, 변하지 않는 값(데이터)를 의미한다.
 코드적으로 말하자면, 상수는 변하지 않는 변수를 뜻한다.

 상수는 숫자만 넣어야 한다고 오해하는 사람들이 많은데,
 앞서 말했듯이, 상수는 변하지 않는 변수를 뜻하는 것이다.
 즉 상수에 넣는 데이터는 숫자가 올 수 도 있지만,
 클래스나 구조체 같이 기본형에서 파생된 객체나 유도형같은 데이터를 넣을 수 있다.

 상수는 데이터가 변하지 않아야 한다고 했다. 그래서
 참조변수를 상수로 지정 할 때, 참조변수에 넣은 인스턴스 안의 데이터 까지도 변하지 않는 줄 착각 할 수 있지만,
 참조변수가 상수(참조변수 메모리의 주소값이 변하지 않는다라는 의미)지,
 그 주소가 가리키는 데이터들까지 상수라는 의미가 아니다.

 프로그래밍에서 상수를 쓸때는 C,C++,C#은 const , Java는 final 제어자를 쓴다.
 Java언어로 예를 들어보자.

 즉 Test라는 클래스를 만들었다면,
 final Test t1 = new Test();
 t1 = new Test();
 는 불가 하지만,

 t1.num = 10;
 이렇게 클래스 안의 데이터를 변경해도 상관이 없다는 의미이다.

 리터럴(Literal)이란?
 리터럴은 데이터 그 자체를 뜻 한다.
 변수에 넣는 변하지 않는 데이터를 의미하는 것이다.

 아래의 예제를 보자.
 int a = 1;
 int 앞에 final를 붙일 시 , a는 상수가 된다. 여기서의 리터럴은 1이다.

 즉, 1과 같이 변하지 않는 데이터(boolean, char, double, long, int, etc...)를 리터럴(literal)이라고 부른다.
 그렇다면 인스턴스(클래스 데이터)가 리터럴이 될 수 있을까?
 답은 아니오다. 만약 인스턴스안에 있는 값들을 변경하지 않는다면 모를까,
 보통의 인스턴스는 동적으로 사용하기 위해 작성되므로.
 리터럴이 될 수가 없다. 왜냐하면 값이 언제 바뀔지 모르는 것이기 때문이다.

 하지만 프로그래밍 에서 객체 리터럴이란 표현을 들어본적이 있을 것이다.
 데이터가 변하지 않도록 설계를 한 클래스를 불변 클래스라 칭한다.(immutable class)

 해당 클래스는 한번 생성하면 객체 안의 데이터가 변하지 않는다. 변할 상황이면 새로운 객체를 만들어준다.
 자바의 String, Color 같은 클래스가 이와 같은 예이다.
 따라서 우리는 "abc" 와 같은 문자열을 자바에서는 '객체 리터럴' 짧게는 '리터럴' 이라고 표현 하는것이다.

 여기까지가 준비한 상수와 리터럴의 내용이다.
 정리하자면 상수는 변하지 않는 변수를 의미하며(메모리 위치) 메모리 값을 변경할 수 없다.
 리터럴은 변수의 값이 변하지 않는 데이터(메모리 위치안의 값)를 의미한다.
 보통은 기본형의 데이터를 의미하지만, 특정 객체(Immutable class , VO class)에 한에서는 리터럴이 될 수 있다.

 출처: https://mommoo.tistory.com/14 [개발자로 홀로 서기]
 */
