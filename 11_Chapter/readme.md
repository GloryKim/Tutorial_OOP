# 11.Relationship of Class
<br>

0. 객체지향프로그래밍에서 클래스는 단독으로 사용되지 않는다.
1. 프로그램에서는 여러개의 클래스를 사용하면 이 클래스들은 서로 연관이 있다.
2. **클래스 관계는 상속(is-a), 연관(is related to), 종속(uses-a), 3가지로 구성되어있다.**
3. 연관(is related to)는 소유, 구성으로 구성되어있다.
4. **식물이라는 클래스는 들국화라는 클래스보다 더 범용적인 개념으로 사용된다.**
5. 즉 '식물은 들국화'다는 거짓이고 '들국화는 식물이다.'는 참이다.
6. **프로그래밍에서는 식물 클래스를 만들고 이를 기반으로 상속해서 Horse 클래스를 만들수 있다.**
7. **6번의 관계를 is-a 관계라고 한다.**
8. **UML은 클래스와 객체들의 관계를 시각적으로 나타내는 언어이다.**
9. UML의 클래스는 직사각형 상자로 나타낸다.
10. UML에서 상속의 관계는 속이 비어있는 세모에 실선을 그려넣어 방향을 가르킨다.
11. 범용적인 클래스를 '베이스클래스'(baseclass) 라고 하고 '슈퍼클래스'(superclass) 라고도 한다.
12. **C++에서 파생 클래스는 베이스 클래스를 확장extend한 것이라고 표현한다.**
13. 파생클래스는 베이스 클래스의 모든 데이터 맴버와 맴버함수를 가진 상태에서(단, 생성자, 소멸자, 할당 연산자는 제외), 추가적인 데이터 맴버와 맴버 함수를 갖는다.
14. 배이스클래스를 기반으로 파생 클래스를 만들 때는 public, protected, private이라는 3가지 선택지가 있다.
15. public상속의 예 :  class D : public B { ..... };
16. Protected상속의 예 :  class D : protected B { ..... };
17. Private상속의 예 :  class D : private B { ..... };
18. **상속의 종류를 따로 지정하지 않으면 private 상속**
19. **명시적으로 상속을 할 때 접근 제한자의 종류를 지정해주는 것이 일반적이다.**
20. 가장 많이 사용되는 상속은 public 이다.
21. '학생'은 '사람'이기에 학생 클레스는 person 클래스의 상속을 받게 구성한다.
22. public 상속 때는 베이스 클래스의 private 맴버함수가 파생 클래스로 상속되기는 한다.
23. 파생 클래스에서 그러한 데이터 멤버에 직접 접근할 수는 없습니다.
24. **파생 클래스에서 베이스 클래스에서 상속된 private 데이터 멤버에 접근하려면 베이스 클래스에서 상속된 public 맴버함수를 통해서 접근해야한다.**
25. **파생 클래스에서 베이스 클래스의 함수를 호출해서 어떤 작업을 하게 만드는 것을 위임(delegation) 이라고 부른다.**
26. 멤버 함수 오버로드
- void set (long identity); // Person 클래스
- void set (double gpa); // Student 클래스
27. **멤버 함수 오버라이드**
- 베이스 클래스와 파생 클래스 모두에 이름도 같고 시그니처도 같은 함수를 만들면, 이를 '오버라이드했다'라고 표현한다.
- long get(); //Person 클래스
- double get(); //Student 클래스
28. 클래스 스코프
- Public 상속을 할 때에 스코프가 생긴다.
- 베이스 클래스도 자신의 스코프를 갖고 파생 클래스도 자신의 스코프를 갖는다.
29. 컴파일러는 다음과 같은 규칙에 따라서 적절한 스코프의 맴버 함수를 호출한다.
- 컴파일러는 맴버함수를 호출한 객체의 클래스에서 이름과 매개변수가 같은 함수를 찾는다.
- 만약 찾지 못하면, 베이스 클래스 에서 이름과 매개변수가 같은 함수를 찾는다.
- 만약 찾지 못하면, 계속해서 베이스 클래스의 베이스 클래스를 타고 올라가며 찾는다.
- 상속 계층 전체에서 찾지 못하면, 컴파일 오류를 일으킨다.
30. 상속 되지 않는 맴버 (아래 5개의 맴버 함수는 파생 클래스로 상속되지 않는다.)
- 기본생성자
- 매개변수가 있는 생성자
- 복사 생성자
- 소멸자
- 할당 연산자
31. protected 맴버는 베이스 클래스에서 private 맴버처럼 작동하며, 파생 클래스 에서는 public 맴버처럼 작동합니다.
32. private 데이터 맴버를 사용하면 캡슐화를 유지할수 있다.
33. private 데이터 맴버를 사용하면 클래스 외부의 모든 곳에서 데이터 맴버에 접근할 수 없습니다.
34. 상속 막기
- 클래스 설계자의 입자엥서 클래스의 추가적인 상속을 막고 싶을 때가 있을수 있다.
- class First final { ... }
- final 한정자는 클래스 계층 구조의 어떤 위치에나 붙일수 있다.
- class First {...} class Second final : public First {...}